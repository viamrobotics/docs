from bs4 import BeautifulSoup
from urllib.request import urlopen
from pathlib import Path
import sys
import os
import subprocess
import re as regex
import argparse

from parse_python import PythonParser
from parse_go import GoParser
from parse_flutter import FlutterParser
from parse_typescript import TypeScriptParser
from parser_utils import make_soup

## The full list of SDK languages we scrape. You can use the sdk_languages
## positional parameter to refine this at runtime if desired:
sdks_supported = ["go", "python", "flutter", "typescript"]

## Arrays of resources to scrape, by type:
##   type = ["array", "of", "resources"]
## You can use the target_resources positional parameter to refine this
## at runtime if desired:
components = ["arm", "base", "board", "button", "camera", "encoder", "gantry", "generic_component", "gripper",
              "input_controller", "motor", "movement_sensor", "power_sensor", "sensor", "servo", "switch"]
services = ["base_remote_control", "data_manager", "discovery", "generic_service", "mlmodel", "motion", "navigation", "slam", "vision"]
app_apis = ["app", "billing", "data", "dataset", "data_sync", "mltraining"]
robot_apis = ["robot"]

## Parse arguments passed to update_sdk_methods.py. You can:
## - Provide the specific sdk languages to run against as a comma-separated list, or
##     omit entirely to run against all sdks_supported.
## - Provide the specific resource(s) to run against as a comma-separated list, or
##     omit entirely to run against all resources, across all types. This option
##     only supports arbitrary resources within the same resource type (i.e. all
##     components, or all services).
## - Use 'verbose' mode to enable DEBUG output.
## - Use 'map' mode to generate a proto map template file only.
parser = argparse.ArgumentParser()
parser.add_argument('sdk_languages', type=str, nargs='?', help="A comma-separated list of the sdks to run against. \
                     Can be one of: go, python, flutter. Omit to run against all sdks.")
parser.add_argument('target_resources', type=str, nargs='?', help="A comma-separated list of the resources to run against. \
                     Must be all within the same resource type, like component or service. Omit to run against all resources.")
parser.add_argument('-o', '--overrides', action='store_true', help="Print out the full expected parameter | return description \
                     override filepath to STDOUT. Use with something like:\n \
                     for filename in `python3 .github/workflows/update_sdk_methods.py -o go motion`; do touch $filename; done")
parser.add_argument('-m', '--map', action='store_true', help="Generate initial mapping CSV file from upstream protos. \
                     In this mode, only the initial mapping file is output, no markdown.")
parser.add_argument('-v', '--verbose', action='store_true', help="Run in verbose mode. Writes a debug file containing \
                     the complete data object from parse() to /tmp/update_sdk_methods_debug.txt. \
                     Also prints high-level status updates to STDOUT. \
                     Deletes previous debug file when run again.")
parser.add_argument('-c', '--coverage', action='store_true', help="Fails the build if any methods are unused.")

## Parse provided parameters and arguments, if any:
args = parser.parse_args()
sdk_list = ''
resource_list = ''
only_run_against = ''

if args.map:
    ## We check for args.map again in both proto_map() and run().
    sdks = sdks_supported
else:
    ## Using specific argument names to allow help text to be specific, but checking both
    ## for sdk or resource values, to allow providing either in any position on the CLI.
    if args.sdk_languages is not None:
        first_list = [s.strip() for s in args.sdk_languages.split(",")]
        if True in tuple(x in sdks_supported for x in first_list):
            sdk_list = first_list
        else:
            resource_list = first_list
    if args.target_resources is not None:
        second_list = [s.strip() for s in args.target_resources.split(",")]
        if True in tuple(x in sdks_supported for x in second_list):
            sdk_list = second_list
        else:
            resource_list = second_list

    ## If (one of) the list(s) contains an SDK language name:
    if sdk_list:
        sdks = []
        for sdk_lang in sdk_list:
            if sdk_lang not in sdks_supported:
                print("ERROR: Unsupported SDK language: " + sdk_lang)
                print("Exiting ...")
                exit(1)
            else:
                sdks.append(sdk_lang)
        if not args.overrides:
            print("\nIMPORTANT: You have indicated that you want to run against specific SDKs, instead of all.")
            print("           This will ERASE any existing content for any SDKs which you have not specified.")
            print("           This is suitable for the initial conversion to autogenerated content, but likely")
            print("           not desireable once automation is in full swing. If you do not want this, you should")
            print("           CANCEL this run, and re-run without specifying any SDKs, which will run against all.")
    else:
        sdks = sdks_supported

    ## If (one of) the list(s) does not contain an SDK language name, assume this list is
    ## intended to serve as the resource list, and check each item against its matching
    ## likely resource type. All provided resources must be of the same resource type,
    ## so we can return an error to the operator as soon as any subsequent resource fails
    ## to match to another entry on the first's resource type array (i.e. if first is arm,
    ## we can always safely error and quit if second returns False against same type array: component):
    if resource_list:
        if True in tuple(x in components for x in resource_list) and not False in tuple(x in components for x in resource_list):
            only_run_against = 'components'
            components = resource_list
        elif True in tuple(x in services for x in resource_list) and not False in tuple(x in services for x in resource_list):
            only_run_against = 'services'
            services = resource_list
        elif True in tuple(x in app_apis for x in resource_list) and not False in tuple(x in app_apis for x in resource_list):
            only_run_against = 'app_apis'
            app_apis = resource_list
        elif True in tuple(x in robot_apis for x in resource_list) and not False in tuple(x in robot_apis for x in resource_list):
            only_run_against = 'robot_apis'
            robot_apis = resource_list
        else:
           print("ERROR: Malformed resource list: " + str(resource_list))
           print("       Specified resources must all be within a single resource type, like components or services.")
           print("Exiting ...")
           exit(1)

## If running in verbose mode, print some initial configuration details to the operator:
if args.verbose:
    print('\nVERBOSE MODE: See /tmp/update_sdk_methods_debug.txt for debug output.')
    print('              Note: This file is deleted at the start of each new verbose run.')
    print('              Try, in a separate terminal window:\n')
    print('              DURING RUN: tail -f /tmp/update_sdk_methods_debug.txt')
    print('              AFTER RUN: less /tmp/update_sdk_methods_debug.txt\n')
    if sdk_list:
        print('SDKS OVERRIDE: Only running against ' + str(sdks) + '\n')
    if resource_list:
        print('RESOURCE OVERRIDE: Only running against ' + str(resource_list) + '\n')
    if args.overrides:
        print("ERROR: You cannot use verbose mode with print overrides mode.")
        print("       If you want this script to print the overrides filepaths it needs")
        print("       for param | return description overrides, rerun this script with")
        print("       the -o flag but WITHOUT the -v flag.")
        print("Exiting ...")
        exit(1)

## This script must be run within the 'docs' git repo. Here we check
## to make sure this is the case, and get the root of our git-managed
## repo to use later in parse() and write_markdown():
process_result = subprocess.Popen(['git', 'rev-parse', '--show-toplevel'], \
                     stdout=subprocess.PIPE, \
                     stderr=subprocess.PIPE)
stdout, stderr = process_result.communicate()

if process_result.returncode == 0:
    gitroot = stdout.decode().rstrip()
else:
    print("ERROR: You must run this script within a cloned copy of the 'docs' git repo!")
    print("Exiting ...")
    exit(1)

## Build path to sdk_protos_map.csv file that contains proto-to-methods mapping, used in write_markdown():
proto_map_file = os.path.join(gitroot, '.github/workflows/sdk_protos_map.csv')

## Array mapping language to its root URL:
sdk_url_mapping = {
    "go": "https://pkg.go.dev",
    "python": "https://python.viam.dev",
    "cpp": "https://cpp.viam.dev",
    "typescript": "https://ts.viam.dev",
    "flutter": "https://flutter.viam.dev"
}

## Dictionary of proto API names, with empty methods array, to be filled in for later use by get_proto_apis():
proto_map = {
    "arm": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/arm/v1/arm_grpc.pb.go",
        "name": "ArmServiceClient",
        "methods": []
    },
    "base": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/base/v1/base_grpc.pb.go",
        "name": "BaseServiceClient",
        "methods": []
    },
    "board": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/board/v1/board_grpc.pb.go",
        "name": "BoardServiceClient",
        "methods": []
    },
    "button": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/button/v1/button_grpc.pb.go",
        "name": "ButtonServiceClient",
        "methods": []
    },
    "camera": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/camera/v1/camera_grpc.pb.go",
        "name": "CameraServiceClient",
        "methods": []
    },
    "encoder": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/encoder/v1/encoder_grpc.pb.go",
        "name": "EncoderServiceClient",
        "methods": []
    },
    "gantry": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/gantry/v1/gantry_grpc.pb.go",
        "name": "GantryServiceClient",
        "methods": []
    },
    "generic_component": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/generic/v1/generic_grpc.pb.go",
        "name": "GenericServiceClient",
        "methods": []
    },
    "gripper": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/gripper/v1/gripper_grpc.pb.go",
        "name": "GripperServiceClient",
        "methods": []
    },
    "input_controller": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/inputcontroller/v1/input_controller_grpc.pb.go",
        "name": "InputControllerServiceClient",
        "methods": []
    },
    "motor": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/motor/v1/motor_grpc.pb.go",
        "name": "MotorServiceClient",
        "methods": []
    },
    "movement_sensor": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/movementsensor/v1/movementsensor_grpc.pb.go",
        "name": "MovementSensorServiceClient",
        "methods": []
    },
    "power_sensor": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/powersensor/v1/powersensor_grpc.pb.go",
        "name": "PowerSensorServiceClient",
        "methods": []
    },
    "sensor": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/sensor/v1/sensor_grpc.pb.go",
        "name": "SensorServiceClient",
        "methods": []
    },
    "servo": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/servo/v1/servo_grpc.pb.go",
        "name": "ServoServiceClient",
        "methods": []
    },
    "switch": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/component/switch/v1/switch_grpc.pb.go",
        "name": "SwitchServiceClient",
        "methods": []
    },
    "data_manager": {
        "url": "https://github.com/viamrobotics/api/blob/main/service/datamanager/v1/data_manager_grpc.pb.go",
        "name": "DataManagerServiceClient",
        "methods": []
    },
    "generic_service": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/generic/v1/generic_grpc.pb.go",
        "name": "GenericServiceClient",
        "methods": []
    },
    "mlmodel": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/mlmodel/v1/mlmodel_grpc.pb.go",
        "name": "MLModelServiceClient",
        "methods": []
    },
    "motion": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/motion/v1/motion_grpc.pb.go",
        "name": "MotionServiceClient",
        "methods": []
    },
    "navigation": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/navigation/v1/navigation_grpc.pb.go",
        "name": "NavigationServiceClient",
        "methods": []
    },
    "slam": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/slam/v1/slam_grpc.pb.go",
        "name": "SLAMServiceClient",
        "methods": []
    },
    "vision": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/vision/v1/vision_grpc.pb.go",
        "name": "VisionServiceClient",
        "methods": []
    },
    "app": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/app/v1/app_grpc.pb.go",
        "name": "AppServiceClient",
        "methods": []
    },
    "billing": {
        "url": "https://github.com/viamrobotics/api/blob/main/app/v1/billing_grpc.pb.go",
        "name": "BillingServiceClient",
        "methods": []
    },
    "data": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/app/data/v1/data_grpc.pb.go",
        "name": "DataServiceClient",
        "methods": []
    },
    "dataset": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/app/dataset/v1/dataset_grpc.pb.go",
        "name": "DatasetServiceClient",
        "methods": []
    },
    "data_sync": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/app/datasync/v1/data_sync_grpc.pb.go",
        "name": "DataSyncServiceClient",
        "methods": []
    },
    "discovery": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/service/discovery/v1/discovery_grpc.pb.go",
        "name": "DiscoveryServiceClient",
        "methods": []
    },
    "robot": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/robot/v1/robot_grpc.pb.go",
        "name": "RobotServiceClient",
        "methods": []
    },
    "mltraining": {
        "url": "https://raw.githubusercontent.com/viamrobotics/api/main/app/mltraining/v1/ml_training_grpc.pb.go",
        "name": "MLTrainingServiceClient",
        "methods": []
    }
}

## Inject these URLs, relative to 'docs', into param/return/raises descriptions that contain exact matching key text.
## write_markdown() uses override_description_links via link_description() when it goes to write out descriptions.
## Currently only used for method descriptions, but see commented-out code for usage as optional consideration.
## NOTE: I am assuming we want to link matching text across all SDKs and methods. If not, this array
## will need additional field(s): ( method | sdk ) to narrow match.
## NOTE 2: I omitted links to the SDKs (like for 'datetime', and 'dataclass' since these can be
## separately handled uniformly (perhaps with the {sdk}_datatype_links array for example).
## EXAMPLES: The first two items in this dict correspond to these docs examples:
## EXAMPLE 1: https://docs.viam.com/services/frame-system/#transformpose
## EXAMPLE 2: https://docs.viam.com/services/motion/#moveonmap
override_description_links = {
    "additional transforms": "/services/frame-system/#additional-transforms",
    "SLAM service": "/services/slam/",
    "frame": "/services/frame-system/",
    "Viam app": "https://app.viam.com/",
    "organization settings page": "/manage/reference/organize/",
    "image tags": "/data-ai/train/create-dataset/#label-your-images",
    "API key": "/fleet/cli/#authenticate",
    "board model": "/dev/reference/apis/components/board/"
}

## Map sdk language to specific code fence formatting syntax for that language:
code_fence_fmt = {
    'python': 'python',
    'go': 'go',
    'flutter': 'dart',
    'typescript': 'ts'
}

## Check to see if we have a locally-staged version of any of the supported SDK docs sites.
## If any are detected here, they will be used for all content in parse(), and the live
## version for that SDK docs site will not be scraped at all! First, set empty staging URLs
## to allow us to later action on whether they are empty or not:
python_staging_url = ''
go_staging_url = ''
flutter_staging_url = ''
# TODO: NOT implemented yet
typescript_staging_url = ''

## Check for GO SDK docs staging on local workstation:
go_process_pid = subprocess.run(["ps -ef | grep pkgsite | grep -v grep | awk {'print $2'}"], shell=True, text=True, capture_output=True).stdout.rstrip()

## If we found a staged local instance of the GO SDK docs, determine which port it is using, and build the staging URL to scrape against:
if go_process_pid != '':
    go_process_port = subprocess.run(["lsof -Pp " + go_process_pid + " | grep LISTEN | awk {'print $9'} | sed 's%.*:%%g'"], shell=True, text = True, capture_output=True).stdout.rstrip()
    go_staging_url = 'http://localhost:' + go_process_port
    if args.verbose:
        print('DEBUG: Detected local staged Go SDK docs URL: ' + go_staging_url + '/go.viam.com/rdk')
        print('       Using this URL for all Go content (ignoring live version).')

## Check for Python and Flutter SDK docs staging on local workstation.
## Both use http.server with a user-selected port. This command fetches all possible matches:
http_server_process_pids = subprocess.run(["ps -ef | grep http.server | grep -v grep | awk '{print $2}'"], shell=True, text=True, capture_output=True).stdout.rstrip().split('\n')

## For each http.server processes detected, make educated guesses about which is which, determine the port used, and build the staging URL to scrape against:
for pid in http_server_process_pids:
    http_server_pwd_result = subprocess.run(["lsof -Pp " + pid + " | grep cwd | awk {'print $9'}"], shell=True, text = True, capture_output=True).stdout.rstrip()

    ## Quality guess: Python build process always builds to this directory; safe to assume:
    if 'docs/_build/html' in http_server_pwd_result:
        python_process_port = subprocess.run(["lsof -Pp " + pid + " | grep LISTEN | awk {'print $9'} | sed 's%.*:%%g'"], shell=True, text = True, capture_output=True).stdout.rstrip()
        python_staging_url = 'http://localhost:' + python_process_port
        if args.verbose:
            print('DEBUG: Detected local staged Python SDK docs URL: ' + python_staging_url)
            print('       Using this URL for all Python content (ignoring live version).')

    ## Mediocre guess: Flutter build process likely to have string 'flutter' in cwd, either 'viam-flutter-sdk' as cloned directly, or 'flutter' as renamed by operator.
    ## TODO: If operators run into instances where this script misses a valid Flutter staging URL because the path to that staged HTML artifacts dir has been
    ## renamed in a fashion that does not include the string 'flutter', then change this to just always pick up any instances of http.server that aren't already matched to
    ## Go, above. This would mean that operators cannot run an unrelated http.server instance on this workstation, which they currently can do with present config.
    if 'flutter' in http_server_pwd_result:
        flutter_process_port = subprocess.run(["lsof -Pp " + pid + " | grep LISTEN | awk {'print $9'} | sed 's%.*:%%g'"], shell=True, text = True, capture_output=True).stdout.rstrip()
        flutter_staging_url = 'http://localhost:' + flutter_process_port + '/doc/api'
        if args.verbose:
            print('DEBUG: Detected local staged Flutter SDK docs URL: ' + flutter_staging_url)
            print('       Using this URL for all Flutter content (ignoring live version).')

## Fetch canonical Proto method names.
## Required by Flutter parsing, and for generating the initial mapping file if -m was passed:
def get_proto_apis():
    for api in proto_map.keys():
        api_url = proto_map[api]["url"]
        api_name = proto_map[api]["name"]

        api_page = urlopen(api_url)
        api_html = api_page.read().decode("utf-8")

        ## Protos are presented in plaintext, so we must match by expected raw text:
        proto_regex = 'type ' + regex.escape(api_name) + r'[^{]*\{([^}]+)\}'
        search = regex.search(proto_regex, api_html)
        match_output = search.group()
        split = match_output.splitlines()

        for line in split:
            line = line.strip()
            if line[0].isupper():
                separator = "("
                line = line.split(separator, 1)[0]
                ## Append to proto_map for use later:
                proto_map[api]["methods"].append(line)

    ## Only generate proto mapping template file if 'map' was passed as argument:
    if args.map:

        ## Writing template file with extra '.template' at the end to avoid accidentally clobbering
        ## the prod file if we've already populated it. When ready, change the filename to exactly
        ## sdk_protos_map.csv for this script to use it for proto mapping:
        proto_map_file_template = os.path.join(gitroot, '.github/workflows/sdk_protos_map.csv.template')
        output_file = open('%s' % proto_map_file_template, "w")

        output_file.write('## RESOURCE, PROTO, PYTHON METHOD, GO METHOD, FLUTTER METHOD\n')

        for api in proto_map.keys():
            output_file.write('\n## ' + api.title() + '\n')
            for proto in proto_map[api]['methods']:

                output_file.write(api + ',' + proto + ',\n')

    return proto_map


## Link matching text, used in write_markdown():
## NOTE: Currently does not support formatting for link titles
## (EXAMPLE: bolded DATA tab here: https://docs.viam.com/dev/reference/apis/data-client/#binarydatabyfilter)
def link_description(format_type, full_description, link_text, link_url):

    ## Supports 'md' link styling or 'html' link styling.
    ## The latter in case you want to link raw method usage:
    if format_type == 'md':
        new_linked_text = '[' + link_text + '](' + link_url + ')'
        linked_description = regex.sub(link_text, new_linked_text, full_description)
    elif format_type == 'html':
        new_linked_text = '<a href="' + link_url + '">' + link_text + '</a>'
        linked_description = regex.sub(link_text, new_linked_text, full_description)

    return linked_description

## Fetch SDK documentation for each language in sdks array, by language, by type, by resource, by method.
def parse(type, names):

## TODO:
## - Unify returned method object form. Currently returning raw method usage for Go, and by-param, by-return (and by-raise)
##   breakdown for each method for Python and Flutter. Let's chat about which is useful, and which I should throw away.
##   Raw usage is I think how check_python_methods.py currently does it. Happy to convert Flutter and Py to dump raw usage,
##   if you don't need the per-param,per-return,per-raise stuff.

    ## This parent dictionary will contain all dictionaries:
    ## all_methods[sdk][type][resource]
    all_methods = {}

    ## Iterate through each sdk (like 'python') in sdks array:
    for sdk in sdks:
        if sdk == "go":
            go_parser = GoParser(proto_map_file, go_staging_url)
            all_methods["go"] = go_parser.parse(type, names)
        elif sdk == "python":
            python_parser = PythonParser(proto_map_file, python_staging_url)
            all_methods["python"] = python_parser.parse(type, names)
        elif sdk == "flutter":
            flutter_parser = FlutterParser(proto_map_file, flutter_staging_url)
            all_methods["flutter"] = flutter_parser.parse(type, names, args)
        elif sdk == "typescript":
            typescript_parser = TypeScriptParser(proto_map_file, typescript_staging_url)
            all_methods["typescript"] = typescript_parser.parse(type, names, args)
        else:
            print("unsupported language!")

    return all_methods


# Parse usage string, used in write_markdown():
def parse_method_usage(usage_string):

    # Splitting the usage string by comma to separate parameters and removing unwanted substrings
    parameters = list(filter(None, (param.strip() for param in usage_string.replace("\n\t\t", "").replace("\n\t,", "").replace("\n\t", "").split(','))))
    parsed_usage_string = []

    for param in parameters:
        ## Discard false-positive match for some Go SDK resources which choose to render each param on a newline,
        ## resulting in trailing ',\n)' syntax that is otherwise interpreted here as a param named ')':
        if param != ')':

            ## Initialize variables
            type_link = None
            type_name = ""
            param_type = ""

            ## HACKY: Hardcoding several params and returns. These are: the ctx, extra, and cmd params,
            ## the error return, and several parameters that require type inference.
            if param.startswith('ctx'):
                type_name = "ctx"
                param_type = "Context"
                param_type_link = "https://pkg.go.dev/context#Context"
            elif param.startswith('extra'):
                type_name = "extra"
                param_type = "map[string]interface{}"
                param_type_link = "https://go.dev/blog/maps"
            elif 'cmd' in param:
                type_name = "cmd"
                param_type = "map[string]interface{}"
                param_type_link = "https://go.dev/blog/maps"
            elif param == '<a href="/builtin#error">error</a>':
                type_name = ""
                param_type = "error"
                param_type_link = "https://pkg.go.dev/builtin#error"
            else:
                param_raw = regex.sub(r'<.*?>', '', param).removesuffix(')').split()
                ## Handle channel data types (only used for Board > StreamTicks):
                if len(param_raw) == 3 and param_raw[0] == 'ch':
                    type_name = 'ch chan'
                    param_type = 'Tick'
                    type_link = '#Tick'
                ## Handle named parameters:
                elif len(param_raw) == 2:
                    type_name = param_raw[0]
                    param_type = param_raw[1]
                    links = regex.findall(r'href="([^"]+)">', param)
                    type_link = links[-1] if links else None
                ## Handle returns, or parameters with inferred data types:
                elif len(param_raw) == 1:
                    ## Hardcode for type inference for angleDeg param:
                    if param_raw[0] == 'angleDeg':
                        type_name = 'angleDeg'
                        param_type = 'float64'
                        type_link = '/builtin#float64'
                    ## Hardcode for type inference for linear param:
                    elif param_raw[0] == 'linear':
                        type_name = 'linear'
                        param_type = 'r3.Vector'
                        type_link = '/github.com/golang/geo/r3#Vector'
                    ## Hardcode for type inference for positionsMm param:
                    elif param_raw[0] == 'positionsMm':
                        type_name = 'positionsMm'
                        param_type = '[]float64'
                        type_link = '/builtin#float64'
                    ## Hardcode for type inference for rpm param:
                    elif param_raw[0] == 'rpm':
                        type_name = 'rpm'
                        param_type = 'float64'
                        type_link = '/builtin#float64'
                    ## Hardcode for type inference for srcName param:
                    elif param_raw[0] == 'srcName':
                        type_name = 'srcName'
                        param_type = 'string'
                        type_link = '/builtin#string'
                    ## Handle returns:
                    else:
                        type_name = ''
                        param_type = param_raw[0]
                        links = regex.findall(r'href="([^"]+)">', param)
                        type_link = links[-1] if links else None

                if type_link:
                    param_type_link = type_link
                else:
                    param_type_link = None

            parsed_usage_string.append((type_name, param_type, param_type_link))

    return parsed_usage_string

# Format usage string, used in write_markdown():
def format_method_usage(parsed_usage_string, go_method_name, resource, path_to_methods_override, method_link):
    formatted_output = []
    for type_name, param_type, param_type_link in parsed_usage_string:

        return_string = ""

        ## Creating the parameter type link depending on whether it is an absolute
        ## or relative link, using passed method_link if the latter:
        if param_type_link and param_type_link.startswith('/'):
            param_type_link = f"https://pkg.go.dev{param_type_link}"
        elif param_type_link and param_type_link.startswith('#'):
            param_type_link_base = regex.sub(r'#.*', '', method_link)
            param_type_link = f"{param_type_link_base}{param_type_link}"

        ## Hardcode select parameters / returns, in order to provide their descriptions:
        if type_name == "ctx":
            return_string += f"- `{type_name}` [({param_type})]({param_type_link}): A Context carries a deadline, a cancellation signal, and other values across API boundaries."
        elif type_name == "extra":
            return_string += f"- `{type_name}` [({param_type})]({param_type_link}): Extra options to pass to the underlying RPC call."
        elif go_method_name == "DoCommand" and type_name == "cmd":
            return_string += f"- `{type_name}` [({param_type})]({param_type_link}): The command to execute."
        elif go_method_name == "Reconfigure" and type_name == "deps":
            return_string += f"- `{type_name}` [({param_type})]({param_type_link}): The resource dependencies."
        elif go_method_name == "Reconfigure" and type_name == "conf":
            return_string += f"- `{type_name}` [({param_type})]({param_type_link}): The resource configuration."
        elif go_method_name == "DoCommand" and param_type == "map[string]interface{}":
            return_string += f"- [({param_type})]({param_type_link}): The command response."
        elif go_method_name == "Geometries" and param_type == "[]spatialmath.Geometry":
            return_string += f"- [({param_type})]({param_type_link}): The geometries associated with this resource, in any order."
        elif go_method_name == "Kinematics" and param_type == "referenceframe.Model":
            return_string += f"- [({param_type})]({param_type_link}): The kinematics model of the resource."
        elif go_method_name == "IsMoving" and param_type == "bool":
            return_string += f"- [({param_type})]({param_type_link}): Whether this resource is moving (`true`) or not (`false`)."
        elif go_method_name == "Readings" and param_type == "map[string]interface{}":
            return_string += f"- [({param_type})]({param_type_link}): A map containing the measurements from the sensor. Contents depend on sensor model and can be of any type."
        elif param_type == "error":
            return_string += f"- [({param_type})]({param_type_link}): An error, if one occurred."
        else:
            ## Check for param and return description overrides:
            param_or_return_description = ''
            ## Param override:
            if type_name != '':
                # To handle 'ch chan' param name, similar. Use as 'ch' in override filename:
                if ' ' in type_name:
                    type_name_short = type_name.split(' ')[0]
                else:
                    type_name_short = type_name

                ## .../overrides/methods/{sdk}.{resource}.{method_name}.{param_name}.md
                param_desc_override_file = path_to_methods_override + '/go.' + resource + '.' + go_method_name + '.' + type_name_short + '.md'
            ## Return override:
            else:
                if 'map[string]interface{}' in param_type:
                    return_type_short = 'string'
                elif '.' in param_type:
                    return_type_short = param_type.split('.')[-1]
                elif ']' in param_type:
                    return_type_short = param_type.split(']')[-1]
                else:
                    return_type_short = param_type

                return_type_short = return_type_short.removeprefix('[]').removeprefix('*')

                ## .../overrides/methods/{sdk}.{resource}.{method_name}.{return_type_short}.return.md
                param_desc_override_file = path_to_methods_override + '/go.' + resource + '.' + go_method_name + '.' + return_type_short + '.return.md'

            if args.overrides:
                print(param_desc_override_file)

            if os.path.exists(param_desc_override_file):
                preserve_formatting = False
                for line in open(param_desc_override_file, 'r', encoding='utf-8'):
                    if '<!-- preserve-formatting -->' in line:
                        preserve_formatting = True
                    if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                        param_or_return_description = param_or_return_description + line
                    elif '<!-- preserve-formatting -->' not in line:
                        param_or_return_description = param_or_return_description + line.replace('\n', ' ')
                param_or_return_description = param_or_return_description.rstrip()

            ## If we have a param description override, use that. If not, skip:
            if param_or_return_description != '':

                ## Add a trailing period if it is missing, either from upstream or from override file,
                ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                if not param_or_return_description.endswith('.') and not param_or_return_description.endswith('>'):
                    param_or_return_description = param_or_return_description + '.'

                ## Format returns:
                if type_name == '':
                   return_string += f"- [({param_type})]({param_type_link}): {param_or_return_description}"
                ## Format parameters:
                else:
                   return_string += f"- `{type_name}` [({param_type})]({param_type_link}): {param_or_return_description}"
            else:
                ## Format returns:
                if type_name == '':
                   return_string += f"- [({param_type})]({param_type_link})"
                ## Format parameters:
                else:
                   return_string += f"- `{type_name}` [({param_type})]({param_type_link})"

        formatted_output.append(return_string.rstrip())

    return formatted_output


def check_for_unused_methods(methods, type):
    warnings = False

    with open(proto_map_file, 'r') as f:
        for row in f:
            if not row.startswith('#') and "," in row:
                resource = row.split(',')[0]
                py_method_name = row.split(',')[3]
                go_method_name = row.split(',')[4]
                flutter_method_name = row.split(',')[5].rstrip()
                typescript_method_name = row.split(',')[6].rstrip()

                if py_method_name:
                    if 'python' in sdks and resource in methods['python'][type]:
                        if py_method_name in methods['python'][type][resource]:
                            methods['python'][type][resource][py_method_name]["used"] = True
                        else:
                            print(f"WARNING: {type} {resource} {py_method_name} is specified in SDK protos map but not found in SDK docs")
                            warnings = True

                if go_method_name:
                    if 'go' in sdks and resource in methods['go'][type]:
                        if go_method_name in methods['go'][type][resource]:
                            methods['go'][type][resource][go_method_name]["used"] = True
                        else:
                            print(f"WARNING: {type} {resource} {go_method_name} is specified in SDK protos map but not found in SDK docs")
                            warnings = True

                if flutter_method_name:
                    if 'flutter' in sdks and resource in methods['flutter'][type]:
                        if flutter_method_name in methods['flutter'][type][resource]:
                            methods['flutter'][type][resource][flutter_method_name]["used"] = True
                        else:
                            print(f"WARNING: {type} {resource} {flutter_method_name} is specified in SDK protos map but not found in SDK docs")
                            warnings = True

                if typescript_method_name:
                    if 'typescript' in sdks and resource in methods['typescript'][type]:
                        if typescript_method_name in methods['typescript'][type][resource]:
                            methods['typescript'][type][resource][typescript_method_name]["used"] = True
                        else:
                            print(f"WARNING: {type} {resource} {typescript_method_name} is specified in SDK protos map but not found in SDK docs")
                            warnings = True

    for lang in sdks:
        for resource in methods[lang][type]:
            for method in methods[lang][type][resource]:
                if not "used" in methods[lang][type][resource][method].keys():
                    if resource in ["data_sync", "dataset", "data"]:
                        continue
                    if lang == "python" and method not in ["from_robot", "close", "get_resource_name", "get_geometries", "do_command"] or \
                        lang == "go" and method not in ["Reconfigure", "Stream", "ListTunnels", "Close", "DoCommand", "CurrentPosition"] or \
                        lang == "flutter" and method not in ["getResources", "getStream", "getStreamOptions", "resetStreamOptions", "setStreamOptions", "Discovery.fromProto", "addCallbacks", "getResource"] or \
                        lang == "typescript" and method not in ["connect", "disconnect", "isConnected", "discoverComponents", "createServiceClient", "getRoverRentalRobots", "doCommand"]:
                        print(f"WARNING: {lang} {type} {resource} {method} is unused")
                        warnings = True

    return warnings


## write_markdown() takes the data object returned from parse(), and writes out the markdown
## for each method in that object:
def write_markdown(type, names, methods):

    ## Generate special version of type var that matches how we refer to it in MD filepaths.
    ## This means pluralizing components and services, and taking no action for app and robot:
    if type in ['component', 'service']:
        type_filepath_name = type + 's'
    else:
        type_filepath_name = type

    ## Set 'generated' folder structure and 'override' directories:
    relative_generated_path = 'static/include/' + type_filepath_name + '/apis/generated/'
    path_to_generated = os.path.join(gitroot, relative_generated_path)
    relative_override_path = 'static/include/' + type_filepath_name + '/apis/overrides/'
    path_to_overrides = os.path.join(gitroot, relative_override_path)
    path_to_protos_override = os.path.join(path_to_overrides, 'protos')
    path_to_methods_override = os.path.join(path_to_overrides, 'methods')

    ## Create any missing directories, or take no action if already present:
    Path(path_to_generated).mkdir(parents=True, exist_ok=True)
    Path(path_to_protos_override).mkdir(parents=True, exist_ok=True)
    Path(path_to_methods_override).mkdir(parents=True, exist_ok=True)

    ## NOTE: To use the above override directories, place a file at one of these locations.
    ## IMPORTANT: Filenames are CASE-SENSITIVE!
    ## To override a proto with custom leading MD content, place a file here:
    ##    docs/static/include/{type}/apis/overrides/protos/{resource}.{proto_name}.md
    ## To override a method with custom leading MD content, place a file here:
    ##    docs/static/include/{type}/apis/overrides/methods/{sdk}.{resource}.{method_name}.before.md
    ## To override a method with custom trailing MD content, place a file here:
    ##    docs/static/include/{type}/apis/overrides/methods/{sdk}.{resource}.{method_name}.after.md
    ## To override a specific parameter description for a method with custom MD content, place a file here:
    ##    docs/static/include/{type}/apis/overrides/methods/{sdk}.{resource}.{method_name}.{parameter_name}.md
    ## To override a specific return description for a method with custom MD content, place a file here:
    ##    For Python (can have only one return, returns are not named):
    ##        docs/static/include/{type}/apis/overrides/methods/{sdk}.{resource}.{method_name}.return.md
    ##    For Flutter (can have multiple returns, returns are not named):
    ##        docs/static/include/{type}/apis/overrides/methods/{sdk}.{resource}.{method_name}.{return_type_short}.return.md
    ##    For Go (can have multiple returns, returns are not named):
    ##        docs/static/include/{type}/apis/overrides/methods/{sdk}.{resource}.{method_name}.{return_type_short}.return.md

    ## Loop through each resource, such as 'arm'. run() already calls parse() in
    ## scope limited to 'type', so we don't have to loop by type:
    for resource in names:

        ## Switch to identify the first method encountered for each resource, to help with
        ## knowing when we are at the top of the include file, or whether to double newline
        ## between protos:
        is_first_method_in_this_resource = True

        ## Determine where to write output for this resource:
        full_path_to_resource_file = os.path.join(path_to_generated, resource + '.md')
        output_file = open('%s' % full_path_to_resource_file, "w")

        ## Determine where to write API protos list table for this resource:
        full_path_to_table_file = os.path.join(path_to_generated, resource + '-table.md')
        table_file = open('%s' % full_path_to_table_file, "w")

        ## Loop through mapping file, and determine which sdk methods to document for each proto:
        with open(proto_map_file, 'r') as f:
            for row in f:
                if not row.startswith('#') \
                and row.startswith(resource + ','):
                    proto = row.split(',')[1]
                    micro_rdk_support = row.split(',')[2]
                    py_method_name = row.split(',')[3]
                    go_method_name = row.split(',')[4]
                    flutter_method_name = row.split(',')[5].rstrip()
                    typescript_method_name = row.split(',')[6].rstrip()

                    if py_method_name and "python" in sdks and resource in methods['python'][type]:
                        if py_method_name in methods['python'][type][resource]:
                            methods['python'][type][resource][py_method_name]["used"] = True
                    if go_method_name and "go" in sdks and resource in methods['go'][type]:
                        if go_method_name in methods['go'][type][resource]:
                            methods['go'][type][resource][go_method_name]["used"] = True
                    if flutter_method_name and "flutter" in sdks and resource in methods['flutter'][type]:
                        if flutter_method_name in methods['flutter'][type][resource]:
                            methods['flutter'][type][resource][flutter_method_name]["used"] = True
                    if typescript_method_name and "typescript" in sdks and resource in methods['typescript'][type]:
                        if typescript_method_name in methods['typescript'][type][resource]:
                            methods['typescript'][type][resource][typescript_method_name]["used"] = True

                    ## Allow setting protos with 0 sdk method maps, to allow us to disable writing MD
                    ## for specific protos as needed, if needed:
                    if (py_method_name and "python" in sdks) or (go_method_name and "go" in sdks) or (typescript_method_name and "typescript" in sdks) or (flutter_method_name and "flutter" in sdks):

                        ## We have at least one implemented method for this proto, so begin writing output markdown for this resource.
                        ## Write proto as H3, with leading newlines if appending to ongoing {resource}.md file:
                        if is_first_method_in_this_resource:
                            output_file.write('### ' + proto + '\n\n')
                        else:
                            output_file.write('\n### ' + proto + '\n\n')

                        ## NOTE: This is where proto descriptions could go if we scraped them. However:
                        ## - Some protos do not have descriptions.
                        ## - DOCS provides vastly better descriptions in some cases.
                        ## - DOCS descriptions are often deeply linked to DOCS content.
                        ## We use the proto override system instead to provide these proto descriptions.
                        ## TODO: Consider adding/enhancing proto descriptions to viamrobotics/api,
                        ## and adding descriptions scraping to get_proto_apis().

                        proto_override_filename = resource + '.' + proto + '.md'

                        ## .../overrides/protos/{resource}.{proto}
                        proto_override_file = os.path.join(path_to_protos_override, proto_override_filename)
                        if os.path.isfile(proto_override_file):

                            for line in open(proto_override_file, 'r', encoding='utf-8'):
                                output_file.write(line)

                            if micro_rdk_support == "Yes":
                                output_file.write('Supported by `viam-micro-server`.\n')

                            output_file.write('\n')

                        ## We have at least one implemented method for this proto, so begin writing table list markdown for this resource.
                        ## Add proto name to table_file listing, with standard first three lines.
                        ## We write this here, depending on is_first_method_in_this_resource, in case we have a resource with 0 implemented protos
                        ## down the line, to avoid blank table_files:
                        if is_first_method_in_this_resource and resource != 'movement_sensor':
                            table_file.write('<!-- prettier-ignore -->\n')
                            if micro_rdk_support != '':
                                table_file.write('| Method Name | Description | `viam-micro-server` Support |\n')
                                table_file.write('| ----------- | ----------- | --------------------------- |\n')
                            else:
                                table_file.write('| Method Name | Description |\n')
                                table_file.write('| ----------- | ----------- |\n')

                        ## Determine what the anchor link structure should be for this resource. Each type has its own standard:
                        proto_link = proto.replace('.', '').lower()

                        if type == 'component':
                            ## Replace underscores, and convert generic_component to just generic:
                            resource_adjusted = resource.replace('generic_component', 'generic').replace('_','-')
                            proto_anchor_link = '/dev/reference/apis/components/' + resource_adjusted + '/#' + proto_link
                        elif type == 'service' and resource in ['base_remote_control', 'motion', 'navigation', 'slam', 'vision']:
                            proto_anchor_link = '/dev/reference/apis/services/' + resource.replace('base_remote_control', 'base-rc') + '/#' + proto_link
                        elif type == 'service' and resource == 'data_manager':
                            proto_anchor_link = '/dev/reference/apis/services/data/#' + proto_link
                        elif type == 'service' and resource == 'discovery':
                            proto_anchor_link = '/dev/reference/apis/services/discovery/#' + proto_link
                        elif type == 'service' and resource == 'generic_service':
                            proto_anchor_link = '/dev/reference/apis/services/generic/#' + proto_link
                        elif type == 'service' and resource == 'mlmodel':
                            proto_anchor_link = '/dev/reference/apis/services/ml/#' + proto_link
                        elif type == 'app' and resource == 'app':
                            proto_anchor_link = '/dev/reference/apis/fleet/#' + proto_link
                        elif type == 'app' and resource in ["billing", "mltraining"]:
                            proto_anchor_link = '/dev/reference/apis/' + resource.replace('mltraining','ml-training') + '-client/#' + proto_link
                        elif type == 'app' and resource in ["data", "dataset", "data_sync"]:
                            proto_anchor_link = '/dev/reference/apis/data-client/#' + proto_link
                        elif type == 'robot':
                            proto_anchor_link = '/dev/reference/apis/' + resource + '/#' + proto_link

                        ## Fetch just the first sentence from the proto_override_file (first text string terminated by '.\n'), ignoring hugo
                        ## shortcodes like alerts ('{{%.*%}}.*{{% \[a-b].* %}}'), which precede some override files' (proto descriptions')
                        ## first sentence:


                        with open(proto_override_file, 'r') as f:
                            file_contents = f.read().strip()
                            file_contents = regex.sub(r'\{\{\%.*\%\}\}.*\{\{\% \/[a-b].* \%\}\}', '', file_contents, flags=regex.DOTALL)
                            search_result = file_contents.split('.\n', 1)[0].strip().replace("\n", " ")

                            ## If the proto description contains any MD links, strip them out:
                            search_result = regex.sub(r'\[([A-Za-z0-9\.\(\)\-\_\`\s]*)\]\([A-Za-z0-9\.\:\/\-\_\#]*\)', r'\1', search_result)

                            ## If the proto description is missing a trailing period, or we stripped it off during the above matching, append
                            ## (restore) the period character:
                            if not search_result.endswith('.'):
                                proto_description_first_sentence = search_result + '.'
                            else:
                                proto_description_first_sentence = search_result

                        ## Write out this proto's entry to this resource's table_file:
                        if resource != 'movement_sensor':
                            if micro_rdk_support != '':
                                if micro_rdk_support == 'Yes':
                                    mark = '<p class="center-text"><i class="fas fa-check" title="yes"></i></p>'
                                else:
                                    mark = ''
                                table_file.write('| [`' + proto + '`](' + proto_anchor_link + ') | ' + proto_description_first_sentence + ' | ' + mark +' |\n')
                            else:
                                table_file.write('| [`' + proto + '`](' + proto_anchor_link + ') | ' + proto_description_first_sentence + ' |\n')


                        ## Begin the per-language markdown writing to output_file with the opening tabset declaration:
                        output_file.write('{{< tabs >}}\n')

                        if py_method_name and "python" in sdks:
                            output_file.write('{{% tab name="Python" %}}\n\n')

                            ## Assemble possible method override filepaths. Provide a file at one or both of these locations to
                            ## inject additional MD content either before or after the auto-generated method content:
                            ## 'before': injects immediately after the opening SDK tab and before the first parameter is listed.
                            ## 'after': injects immediately after the code sample (or last return if none), and before the closing SDK tab.
                            ## .../overrides/methods/{sdk}.{resource}.{method_name}.before|after.md
                            before_method_override_filepath = path_to_methods_override + '/python.' + resource + '.' + py_method_name + '.before.md'
                            after_method_override_filepath = path_to_methods_override + '/python.' + resource + '.' + py_method_name + '.after.md'

                            ## If we detected a 'before' method override file, write it out here:
                            if os.path.exists(before_method_override_filepath):
                                for line in open(before_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            output_file.write('**Parameters:**\n\n')

                            if 'parameters' in methods['python'][type][resource][py_method_name]:

                                for parameter in methods['python'][type][resource][py_method_name]['parameters'].keys():

                                    param_data = methods['python'][type][resource][py_method_name]['parameters'][parameter]

                                    param_type = param_data.get("param_type")

                                    param_description = ''
                                    ## .../overrides/methods/{sdk}.{resource}.{py_method_name}.{param_name}.md
                                    param_desc_override_file = path_to_methods_override + '/python.' + resource + '.' + py_method_name + '.' + parameter + '.md'

                                    if args.overrides:
                                        print(param_desc_override_file)

                                    if os.path.exists(param_desc_override_file):
                                        preserve_formatting = False
                                        for line in open(param_desc_override_file, 'r', encoding='utf-8'):
                                            if '<!-- preserve-formatting -->' in line:
                                                preserve_formatting = True
                                            if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                                                param_description = param_description + line
                                            elif '<!-- preserve-formatting -->' not in line:
                                                param_description = param_description + line.replace('\n', ' ')
                                        param_description = param_description.rstrip()
                                    else:
                                        try:
                                            param_description = param_data.get("param_description").strip()
                                        except:
                                            param_description = ''
                                            print(f'DEBUG: No param description for {py_method_name}.{parameter}')

                                    optional = param_data.get("optional")

                                    output_file.write(f'- `{parameter}` ({param_type})')

                                    if optional:
                                        output_file.write(' (optional)')
                                    else:
                                        output_file.write(' (required)')

                                    if param_description:

                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not param_description.endswith('.') and not param_description.endswith('>'):
                                            param_description = param_description + '.'

                                        output_file.write(f": {param_description}")

                                    # line break for parameters list
                                    output_file.write('\n')

                            # Handle case where no parameters are found
                            else:
                                output_file.write("- None.\n")

                            output_file.write('\n**Returns:**\n\n')

                            if 'return' in methods['python'][type][resource][py_method_name]:

                                return_data = methods['python'][type][resource][py_method_name]["return"]
                                return_type = return_data.get("return_type")

                                return_description = ''
                                ## .../overrides/methods/{sdk}.{resource}.{py_method_name}.return.md
                                return_desc_override_file = path_to_methods_override + '/python.' + resource + '.' + py_method_name + '.return.md'

                                if args.overrides:
                                    print(return_desc_override_file)

                                if os.path.exists(return_desc_override_file):
                                    preserve_formatting = False
                                    for line in open(return_desc_override_file, 'r', encoding='utf-8'):
                                        if '<!-- preserve-formatting -->' in line:
                                            preserve_formatting = True
                                        if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                                            return_description = return_description + line
                                        elif '<!-- preserve-formatting -->' not in line:
                                            return_description = return_description + line.replace('\n', ' ')
                                    return_description = return_description.rstrip()
                                else:
                                    return_description = return_data.get("return_description")

                                if return_type:
                                    output_file.write(f"- ({return_type})")

                                    if return_description:

                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not return_description.endswith('.') and not return_description.endswith('>'):
                                            return_description = return_description + '.'

                                        output_file.write(f": {return_description}\n")
                                    else:
                                        output_file.write("\n")
                            # Handle case where no returns are found
                            else:
                                output_file.write("- None.\n")

                            if 'raises' in methods['python'][type][resource][py_method_name]:
                                output_file.write('\n**Raises:**\n\n')

                                raises_object = methods['python'][type][resource][py_method_name]["raises"]
                                raises_types = methods['python'][type][resource][py_method_name]["raises"].keys()
                                for raises_type in raises_types:
                                    output_file.write(f"- ({raises_type})")
                                    if "raises_description" in raises_object[raises_type]:
                                        raises_description= raises_object[raises_type]["raises_description"]
                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not raises_description.endswith('.') and not raises_description.endswith('>'):
                                            raises_description = raises_description + '.'

                                        output_file.write(f": {raises_description}\n")
                                    else:
                                        output_file.write("\n")

                            ## If the method has a code sample, print it here:
                            if 'code_sample' in methods['python'][type][resource][py_method_name]:

                                output_file.write('\n**Example:**\n')
                                output_file.write('\n```' + code_fence_fmt['python'] + ' {class="line-numbers linkable-line-numbers"}\n')
                                output_file.write(methods['python'][type][resource][py_method_name]['code_sample'])
                                output_file.write('```\n')

                            ## If we detected an 'after' method override file earlier, write it out here:
                            if os.path.exists(after_method_override_filepath):

                                output_file.write('\n')
                                for line in open(after_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            # Output the method link
                            output_file.write(f'\nFor more information, see the [Python SDK Docs]({methods["python"][type][resource][py_method_name]["method_link"]}).\n\n')

                            # Close tabs
                            output_file.write("{{% /tab %}}\n")
                            if not (go_method_name and "go" in sdks) and not (flutter_method_name and "flutter" in sdks) and not (typescript_method_name and "typescript" in sdks):
                                output_file.write("{{< /tabs >}}\n")

                        if go_method_name and "go" in sdks:
                            output_file.write('{{% tab name="Go" %}}\n\n')

                            ## Assemble possible method override filepaths. Provide a file at one or both of these locations to
                            ## inject additional MD content either before or after the auto-generated method content:
                            ## 'before': injects immediately after the opening SDK tab and before the first parameter is listed.
                            ## 'after': injects immediately after the code sample (or last return if none), and before the closing SDK tab.
                            ## .../overrides/methods/{sdk}.{resource}.{method_name}.before|after.md
                            before_method_override_filepath = path_to_methods_override + '/go.' + resource + '.' + go_method_name + '.before.md'
                            after_method_override_filepath = path_to_methods_override + '/go.' + resource + '.' + go_method_name + '.after.md'

                            ## If we detected a 'before' method override file, write it out here:
                            if os.path.exists(before_method_override_filepath):
                                for line in open(before_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                                output_file.write('\n')

                            if 'usage' in methods['go'][type][resource][go_method_name]:

                                method_usage = methods['go'][type][resource][go_method_name]['usage']

                                usage_string = method_usage.split('(')

                                parameters = ''

                                if len(usage_string) == 3:
                                    parameters = usage_string[1]
                                    returns = usage_string[2]

                                else:
                                    usage_string = usage_string[1].split(') ')

                                    if usage_string[0] != '':
                                        parameters = usage_string[0]
                                        if len(usage_string) == 2:
                                            returns = usage_string[1]
                                    else:
                                        returns = usage_string[1]

                                output_file.write('**Parameters:**\n\n')

                                if len(parameters) > 0:
                                    # Parse and format parameters
                                    parsed_parameters = parse_method_usage(parameters)
                                    formatted_parameters = format_method_usage(parsed_parameters, go_method_name, resource, path_to_methods_override, methods["go"][type][resource][go_method_name]["method_link"])

                                    ## NOTE: Use commented-out print statements in formatted_returns() if populating override files.

                                    for line in formatted_parameters:
                                        output_file.write(line + '\n')
                                # Handle case where no parameters are found
                                else:
                                    output_file.write("- None.\n")

                                output_file.write('\n**Returns:**\n\n')
                                if returns:
                                    # Parse and format returns

                                    parsed_returns = parse_method_usage(returns)
                                    formatted_returns = format_method_usage(parsed_returns, go_method_name, resource, path_to_methods_override, methods["go"][type][resource][go_method_name]["method_link"])

                                    ## NOTE: Use commented-out print statements in formatted_returns() if populating override files.

                                    for line in formatted_returns:
                                        output_file.write(line + '\n')
                                # Handle case where no returns are found
                                else:
                                    output_file.write("- None.\n")

                            ## If the method has a code sample, print it here:
                            if 'code_sample' in methods['go'][type][resource][go_method_name]:

                                output_file.write('\n**Example:**\n')
                                output_file.write('\n```' + code_fence_fmt['go'] + ' {class="line-numbers linkable-line-numbers"}\n')
                                output_file.write(methods['go'][type][resource][go_method_name]['code_sample'])
                                output_file.write('```\n')

                            ## If we detected an 'after' method override file earlier, write it out here:
                            if os.path.exists(after_method_override_filepath):

                                output_file.write('\n')
                                for line in open(after_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            # Output the method link
                            output_file.write(f'\nFor more information, see the [Go SDK Docs]({methods["go"][type][resource][go_method_name]["method_link"]}).\n\n')

                            output_file.write("{{% /tab %}}\n")
                            if not (typescript_method_name and "typescript" in sdks) and not(flutter_method_name and "flutter" in sdks):
                                output_file.write("{{< /tabs >}}\n")

                        if typescript_method_name and "typescript" in sdks:
                            output_file.write('{{% tab name="TypeScript" %}}\n\n')

                            ## Assemble possible method override filepaths. Provide a file at one or both of these locations to
                            ## inject additional MD content either before or after the auto-generated method content:
                            ## 'before': injects immediately after the opening SDK tab and before the first parameter is listed.
                            ## 'after': injects immediately after the code sample (or last return if none), and before the closing SDK tab.
                            ## .../overrides/methods/{sdk}.{resource}.{method_name}.before|after.md
                            before_method_override_filepath = path_to_methods_override + '/typescript.' + resource + '.' + typescript_method_name + '.before.md'
                            after_method_override_filepath = path_to_methods_override + '/typescript.' + resource + '.' + typescript_method_name + '.after.md'

                            ## If we detected a 'before' method override file, write it out here:
                            if os.path.exists(before_method_override_filepath):
                                for line in open(before_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            output_file.write('**Parameters:**\n\n')

                            if typescript_method_name not in methods['typescript'][type][resource]:
                                print("ERROR: Method not found in typescript SDK: ", typescript_method_name, type, resource)
                                continue

                            if 'parameters' in methods['typescript'][type][resource][typescript_method_name] and methods['typescript'][type][resource][typescript_method_name]['parameters']:

                                for parameter in methods['typescript'][type][resource][typescript_method_name]['parameters'].keys():

                                    param_data = methods['typescript'][type][resource][typescript_method_name]['parameters'][parameter]

                                    param_type = param_data.get("param_type")

                                    param_description = ''
                                    ## .../overrides/methods/{sdk}.{resource}.{typescript_method_name}.{param_name}.md
                                    param_desc_override_file = path_to_methods_override + '/typescript.' + resource + '.' + typescript_method_name + '.' + parameter + '.md'

                                    if args.overrides:
                                        print(param_desc_override_file)

                                    if os.path.exists(param_desc_override_file):
                                        preserve_formatting = False
                                        for line in open(param_desc_override_file, 'r', encoding='utf-8'):
                                            if '<!-- preserve-formatting -->' in line:
                                                preserve_formatting = True
                                            if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                                                param_description = param_description + line
                                            elif '<!-- preserve-formatting -->' not in line:
                                                param_description = param_description + line.replace('\n', ' ')
                                        param_description = param_description.rstrip()
                                    else:
                                        param_description = param_data.get("param_description").strip()

                                    optional = param_data.get("optional")

                                    output_file.write(f'- `{parameter}` ({param_type})')

                                    if optional:
                                        output_file.write(' (optional)')
                                    else:
                                        output_file.write(' (required)')

                                    if param_description:

                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not param_description.endswith('.') and not param_description.endswith('>'):
                                            param_description = param_description + '.'

                                        output_file.write(f": {param_description}")

                                    # line break for parameters list
                                    output_file.write('\n')

                            # Handle case where no parameters are found
                            else:
                                output_file.write("- None.\n")

                            output_file.write('\n**Returns:**\n\n')

                            if 'return' in methods['typescript'][type][resource][typescript_method_name]:

                                return_data = methods['typescript'][type][resource][typescript_method_name]["return"]
                                return_type = return_data.get("return_type")

                                return_description = ''
                                ## .../overrides/methods/{sdk}.{resource}.{typescript_method_name}.return.md
                                return_desc_override_file = path_to_methods_override + '/python.' + resource + '.' + typescript_method_name + '.return.md'

                                if args.overrides:
                                    print(return_desc_override_file)

                                if os.path.exists(return_desc_override_file):
                                    preserve_formatting = False
                                    for line in open(return_desc_override_file, 'r', encoding='utf-8'):
                                        if '<!-- preserve-formatting -->' in line:
                                            preserve_formatting = True
                                        if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                                            return_description = return_description + line
                                        elif '<!-- preserve-formatting -->' not in line:
                                            return_description = return_description + line.replace('\n', ' ')
                                    return_description = return_description.rstrip()
                                else:
                                    return_description = return_data.get("return_description")

                                if return_type:
                                    output_file.write(f"- ({return_type})")

                                    if return_description:

                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not return_description.endswith('.') and not return_description.endswith('>'):
                                            return_description = return_description + '.'

                                        output_file.write(f": {return_description}\n")
                                    else:
                                        output_file.write("\n")
                            # Handle case where no returns are found
                            else:
                                output_file.write("- None.\n")

                            if 'raises' in methods['typescript'][type][resource][typescript_method_name]:
                                output_file.write('\n**Raises:**\n\n')

                                raises_object = methods['typescript'][type][resource][typescript_method_name]["raises"]
                                raises_types = methods['typescript'][type][resource][typescript_method_name]["raises"].keys()
                                for raises_type in raises_types:
                                    output_file.write(f"- ({raises_type})")
                                    if "raises_description" in raises_object[raises_type]:
                                        raises_description= raises_object[raises_type]["raises_description"]
                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not raises_description.endswith('.') and not raises_description.endswith('>'):
                                            raises_description = raises_description + '.'

                                        output_file.write(f": {raises_description}\n")
                                    else:
                                        output_file.write("\n")

                            ## If the method has a code sample, print it here:
                            if 'code_sample' in methods['typescript'][type][resource][typescript_method_name]:

                                output_file.write('\n**Example:**\n')
                                output_file.write('\n```' + code_fence_fmt['typescript'] + ' {class="line-numbers linkable-line-numbers"}\n')
                                output_file.write(methods['typescript'][type][resource][typescript_method_name]['code_sample'])
                                output_file.write('```\n')

                            ## If we detected an 'after' method override file earlier, write it out here:
                            if os.path.exists(after_method_override_filepath):

                                output_file.write('\n')
                                for line in open(after_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            # Output the method link
                            output_file.write(f'\nFor more information, see the [TypeScript SDK Docs]({methods["typescript"][type][resource][typescript_method_name]["method_link"]}).\n\n')

                            # Close tabs
                            output_file.write("{{% /tab %}}\n")
                            if not (flutter_method_name and "flutter" in sdks):
                                output_file.write("{{< /tabs >}}\n")



                        if flutter_method_name and "flutter" in sdks:
                            output_file.write('{{% tab name="Flutter" %}}\n\n')

                            ## Assemble possible method override filepaths. Provide a file at one or both of these locations to
                            ## inject additional MD content either before or after the auto-generated method content:
                            ## 'before': injects immediately after the opening SDK tab and before the first parameter is listed.
                            ## 'after': injects immediately after the code sample (or last return if none), and before the closing SDK tab.
                            ## .../overrides/methods/{sdk}.{resource}.{method_name}.before|after.md
                            before_method_override_filepath = path_to_methods_override + '/flutter.' + resource + '.' + flutter_method_name + '.before.md'
                            after_method_override_filepath = path_to_methods_override + '/flutter.' + resource + '.' + flutter_method_name + '.after.md'

                            ## If we detected a 'before' method override file, write it out here:
                            if os.path.exists(before_method_override_filepath):
                                for line in open(before_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            output_file.write('**Parameters:**\n\n')
                            if 'parameters' in methods['flutter'][type][resource][flutter_method_name]:

                                for parameter in methods['flutter'][type][resource][flutter_method_name]['parameters'].keys():

                                    param_data = methods['flutter'][type][resource][flutter_method_name]['parameters'][parameter]

                                    param_type = param_data.get("param_type")
                                    param_usage = param_data.get("param_usage")

                                    param_description = ''
                                    ## .../overrides/methods/{sdk}.{resource}.{method_name}.{param_name}.md
                                    param_desc_override_file = path_to_methods_override + '/flutter.' + resource + '.' + flutter_method_name + '.' + parameter + '.md'

                                    if args.overrides:
                                        print(param_desc_override_file)

                                    ## Check if param description override file exists:
                                    if os.path.exists(param_desc_override_file):
                                        preserve_formatting = False
                                        for line in open(param_desc_override_file, 'r', encoding='utf-8'):
                                            if '<!-- preserve-formatting -->' in line:
                                                preserve_formatting = True
                                            if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                                                param_description = param_description + line
                                            elif '<!-- preserve-formatting -->' not in line:
                                                param_description = param_description + line.replace('\n', ' ')
                                        param_description = param_description.rstrip()
                                    else:
                                        param_description = param_data.get("param_description")

                                    optional = param_data.get("optional")

                                    output_file.write(f'- `{parameter}` {param_usage}')

                                    if optional:
                                        output_file.write(' (optional)')
                                    else:
                                        output_file.write(' (required)')

                                    if param_description:

                                        ## Add a trailing period if it is missing, either from upstream or from override file,
                                        ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                        if not param_description.endswith('.') and not param_description.endswith('>'):
                                            param_description = param_description + '.'

                                        output_file.write(f": {param_description}")

                                    # line break for parameters list
                                    output_file.write('\n')

                            # Handle case where no parameters are found
                            else:
                                output_file.write("- None.\n")

                            output_file.write('\n**Returns:**\n\n')
                            if 'return' in methods['flutter'][type][resource][flutter_method_name]:

                                for return_type in methods['flutter'][type][resource][flutter_method_name]["return"].keys():

                                    return_data = methods['flutter'][type][resource][flutter_method_name]["return"][return_type]
                                    return_usage = return_data.get("return_usage")

                                    return_description = ''

                                    if '<' in return_type:
                                        return_type_short = return_type.split('<')[1].split('>')[0].split(',')[0]
                                    else:
                                        return_type_short = return_type

                                    ## .../overrides/methods/{sdk}.{resource}.{flutter_method_name}.{return_type_short}.return.md
                                    return_desc_override_file = path_to_methods_override + '/flutter.' + resource + '.' + flutter_method_name + '.' + return_type_short + '.return.md'

                                    if args.overrides:
                                        print(return_desc_override_file)

                                    ## Check if return description override file exists:
                                    if os.path.exists(return_desc_override_file):
                                        preserve_formatting = False
                                        for line in open(return_desc_override_file, 'r', encoding='utf-8'):
                                            if '<!-- preserve-formatting -->' in line:
                                                preserve_formatting = True
                                            if preserve_formatting and '<!-- preserve-formatting -->' not in line:
                                                return_description = return_description + line
                                            elif '<!-- preserve-formatting -->' not in line:
                                                return_description = return_description + line.replace('\n', ' ')
                                        return_description = return_description.rstrip()
                                    else:
                                        return_description = return_data.get("return_description")

                                    if return_type:
                                        output_file.write(f"- {return_usage}")

                                        if return_description:

                                            ## Add a trailing period if it is missing, either from upstream or from override file,
                                            ## but skip doing so if the copy instead ends with an HTML tag (like a closing '</ul>' tag):
                                            if not return_description.endswith('.') and not return_description.endswith('>'):
                                                return_description = return_description + '.'

                                            output_file.write(f": {return_description}\n")
                                        else:
                                            output_file.write("\n")
                            else:
                                # Handle case where no returns are found
                                output_file.write("- None.\n")

                            ## If the method has a code sample, print it here:
                            if 'code_sample' in methods['flutter'][type][resource][flutter_method_name]:

                                output_file.write('\n**Example:**\n')
                                output_file.write('\n```' + code_fence_fmt['flutter'] + ' {class="line-numbers linkable-line-numbers"}\n')
                                output_file.write(methods['flutter'][type][resource][flutter_method_name]['code_sample'])
                                output_file.write('```\n')

                            ## If we detected an 'after' method override file earlier, write it out here:
                            if os.path.exists(after_method_override_filepath):

                                output_file.write('\n')
                                for line in open(after_method_override_filepath, 'r', encoding='utf-8'):
                                    output_file.write(line)

                            # Output the method link
                            output_file.write(f'\nFor more information, see the [Flutter SDK Docs]({methods["flutter"][type][resource][flutter_method_name]["method_link"]}).\n\n')

                            output_file.write("{{% /tab %}}\n")
                            output_file.write("{{< /tabs >}}\n")

                        ## After this loop, we will be working with additional methods appended to the same {resource}.md include file.
                        ## This switch tells us at the start of the loop for this same resource that we should double-newline the next
                        ## proto encountered:
                        is_first_method_in_this_resource = False


        ## Close file handles:
        output_file.close()
        table_file.close()

        ## When running against specific languages using the sdks array, it is possible to create empty target files.
        ## If such empty target files are present on the local filesystem, remove them:
        if os.path.isfile(full_path_to_resource_file) and os.path.getsize(full_path_to_resource_file) == 0:
            os.remove(full_path_to_resource_file)
        if os.path.isfile(full_path_to_table_file) and os.path.getsize(full_path_to_table_file) == 0:
            os.remove(full_path_to_table_file)

## Main run function:
## - proto_map()        Fetch canonical proto methods from upstream, used for Flutter mapping in `parse()`
## - parse()            Get methods for each defined type & resource, return data object for each, by SDK
## - write_markdown()   Write out salient fields from passed data object to specific MD files
def run():

    exit_code = 0

    ## If generating the mapping template file, skip all other functionality:
    if args.map:
        if args.verbose:
            print('DEBUG: Now fetching upstream PROTOs')
        proto_map = get_proto_apis()
        if args.verbose:
            print('DEBUG: Completed fetching upstream PROTOs!')

    ## Otherwise, continue as normal:
    else:

        ## If running in verbose mode:
        if args.verbose:
            debug_filepath = os.path.join('/tmp/', 'update_sdk_methods_debug.txt')
            ## Delete debug file from last run:
            if os.path.isfile(debug_filepath):
                os.remove(debug_filepath)
            debug_file = open('%s' % debug_filepath, "w")

        ## Parse components:
        if only_run_against not in ['services', 'app_apis', 'robot_apis']:
            if args.verbose:
                print('DEBUG: Now parsing upstream COMPONENT methods for: ' + str(sdks))
            component_methods = parse("component", components)
            if args.verbose:
                print('DEBUG: Completed parsing upstream COMPONENT methods!')
                debug_file.write(str(component_methods) + '\n')
                print('DEBUG: Now writing markdown for COMPONENT methods for: ' + str(sdks))
            write_markdown("component", components, component_methods)
            if args.verbose:
                print('DEBUG: Completed writing markdown for COMPONENT methods!')
            if check_for_unused_methods(component_methods, "component"):
                exit_code = 1

        ## Parse services:
        if only_run_against not in ['components', 'app_apis', 'robot_apis']:
            if args.verbose:
                print('DEBUG: Now parsing upstream SERVICE methods for: ' + str(sdks))
            service_methods = parse("service", services)
            if args.verbose:
                print('DEBUG: Completed parsing upstream SERVICE methods!')
                debug_file.write(str(service_methods) + '\n')
                print('DEBUG: Now writing markdown for SERVICE methods for: ' + str(sdks))
            write_markdown("service", services, service_methods)
            if args.verbose:
                print('DEBUG: Completed writing markdown for SERVICE methods!')
            if check_for_unused_methods(service_methods, "service"):
                exit_code = 1

        ## Parse app client:
        if only_run_against not in ['components', 'services', 'robot_apis']:
            if args.verbose:
                print('DEBUG: Now parsing upstream APP methods for: ' + str(sdks))
            app_methods = parse("app", app_apis)
            if args.verbose:
                print('DEBUG: Completed parsing upstream APP methods!')
                debug_file.write(str(app_methods) + '\n')
                print('DEBUG: Now writing markdown for APP methods for: ' + str(sdks))
            write_markdown("app", app_apis, app_methods)
            if args.verbose:
                print('DEBUG: Completed writing markdown for APP methods!')
            if check_for_unused_methods(app_methods, "app"):
                exit_code = 1
        ## Parse robot client:
        if only_run_against not in ['components', 'services', 'app_apis']:
            if args.verbose:
                print('DEBUG: Now parsing upstream ROBOT methods for: ' + str(sdks))
            robot_methods = parse("robot", robot_apis)
            if args.verbose:
                print('DEBUG: Completed parsing upstream ROBOT methods!')
                debug_file.write(str(robot_methods) + '\n')
                print('DEBUG: Now writing markdown for ROBOT methods for: ' + str(sdks))
            write_markdown("robot", robot_apis, robot_methods)
            if args.verbose:
                print('DEBUG: Completed writing markdown for ROBOT methods!')
            if check_for_unused_methods(robot_methods, "robot"):
                exit_code = 1

        if exit_code == 1 and args.coverage:
            sys.exit("Warnings present in the SDK docs. Please check the logs for more information.")

run()

sys.exit(0)