---
title: "Configure a LoRaWAN network"
linkTitle: "LoRaWAN"
weight: 60
type: "docs"
description: "Configure a gateway and nodes to communicate over the LoRaWAN protocol."
tags: ["sensor", "components", "lorawan", "gateway", "node"]
icon: true
images: ["/icons/components/sensor.svg"]
---

[LoRaWAN (Long Range Wide Area Network)](https://lora-alliance.org/) enables sensor communication spanning kilometers with minimal power usage.

To collect LoRaWAN sensor data with Viam, use the [`lorawan`](https://app.viam.com/module/viam/lorawan) {{< glossary_tooltip term_id="module" text="module" >}}. You can find the module's source code in the [lorawan GitHub repository](https://github.com/viam-modules/lorawan).

## Hardware requirements

- a [supported LoRaWAN gateway](https://github.com/viam-modules/lorawan?tab=readme-ov-file#lorawan-gateway-models-provided)
- a [supported LoRaWAN node](https://github.com/viam-modules/lorawan?tab=readme-ov-file#lorawan-sensor-models-provided)

## Architecture

You can use Viam to create LoRaWAN networks containing one gateway and multiple nodes.
In a LoRaWAN network, information flows in two directions:

- **uplink** transmits from nodes to gateways
- **downlink** transmits from gateways to nodes

![A LoRaWAN network consisting of a single gateway and multiple nodes](/components/sensor/lorawan.png)

### Node

Nodes measure data like any other sensor.
Instead of physically connecting to a machine over GPIO pins or USB, nodes communicate with your machine using the wireless LoRaWAN protocol.
Because LoRaWAN supports communication over distances of up to 10 kilometers, you can distribute nodes over an area of over 300 km<sup>2</sup>.
Nodes typically run off of battery power, with battery life from a single coin cell battery measured in weeks or months.

### Gateway

Gateways collect data generated by LoRaWAN nodes.
A gateway is a device that communicates with nodes over LoRaWAN.
Add a gateway to a Viam machine to sync data from many sensors to a single collection in the Viam cloud, where you can aggregate and visualize your data.
With Viam's `lorawan` module, your gateway also acts as a network server.

## Add a gateway

To start your network, you need a gateway.
The lorawan module supports the following varieties of gateway hardware:

- SBC peripherals built on the SX1302 or SX1303 chips, such as the [Waveshare SX1302 Gateway HAT](https://www.waveshare.com/wiki/SX1302_LoRaWAN_Gateway_HAT)
- dedicated machines such as the Raspberry Pi CM4-based [RAK7391 WisGate Connect](https://docs.rakwireless.com/product-categories/wisgate/rak7391/overview/)

If you choose the RAK7391:

1. Complete the [RAKPiOS quickstart](https://docs.rakwireless.com/product-categories/software-apis-and-libraries/rakpios/quickstart/) to flash your RAK7391 with an operating system and connect it to the network.
1. [Install viam-server](https://docs.viam.com/operate/get-started/setup/).

If you choose a peripheral:

1. Follow our guide to [set up an SBC](/operate/get-started/setup/).
1. Enable SPI on your machine:

   ```console
   sudo raspi-config nonint do_spi 0
   ```

1. Follow the instructions provided by your peripheral manufacturer (for example, the [Waveshare SX1302 LoRaWAN Gateway HAT instructions](https://www.waveshare.com/wiki/SX1302_LoRaWAN_Gateway_HAT)) to physically connect your peripheral to your SBC.
   For supported models, there is no need to configure drivers and software; `viam-server` handles software configuration for you.

After setting up your gateway hardware, complete the following steps to configure your gateway:

{{< tabs >}}
{{% tab name="Builder" %}}

Open your machine's page in the [Viam app](https://app.viam.com) and navigate to the **CONFIGURE** tab.

First, add a `board` component:

1. Click the **+** icon next to your machine part in the left-hand menu and select **Component or service**.
1. Select the `board` type, then select the model that matches your machine.
   For instance, if you connected a peripheral gateway to a Raspberry Pi 5, choose `raspberry-pi:rpi5`.
   If you have a RAK7391, choose `raspberry-pi:rpi` to represent the internal Raspberry Pi Compute Module 4.
1. Click **Add module**, and enter a name for your board.
1. Click **Create** to add the module to your machine.

Next, add a `lorawan` gateway component:

1. Click the **+** icon next to your machine part in the left-hand menu and select **Component or service**.
1. Select the `sensor` type, then select the `lorawan` model that matches the name of your gateway.
   If your SX1302- or SX1303-based peripheral lacks a dedicated model, choose `lorawan:sx1302-hat-generic`.
1. Click **Add module**, and enter a name for your gateway.
1. Click **Create** to add the module to your machine.
1. Click **Save** in the top right to apply your changes and load your new module.

{{% /tab %}}
{{% tab name="JSON Configuration" %}}

In the `components` section of your machine configuration, add the following objects:

```json
{
  "name": "<lorawan-gateway-board>",
  "api": "rdk:component:board",
  "model": "viam:raspberry-pi:<your-pi-model>",
  "attributes": {}
},
{
  "name": "<your-gateway-name>",
  "api": "rdk:component:sensor",
  "model": "viam:lorawan:<gateway-sensor-name>",
  "attributes": {
    "board": "<lorawan-gateway-board>",
    "spi_bus": "<spi-bus-number>",
    "region_code": "<region-code>"
  }
}
```

Choose an appropriate board model based from the [board components registry](/operate/reference/components/board/).

Choose an appropriate gateway model from the following options:

- `viam:lorawan:sx1302-waveshare-hat`: Waveshare LoRaWAN SX1302 Gateway HAT
- `viam:lorawan:sx1302-hat-generic`: generic model for all other peripherals built using the SX1302 or SX1303 chips
- `viam:lorawan:rak7391`: RAK7391 WisGate Connect

Configure attributes based on the tables below:

{{% /tab %}}
{{< /tabs >}}

The following attributes are available for SX1302-based LoRaWAN gateways:

<!-- prettier-ignore -->
| Name | Type | Required? | Description |
| ---- | ---- | --------- | ----------- |
| `board` | string | **Required** | Name of the [board component](/operate/reference/components/board/) that the peripheral is connected to. Used for GPIO pin control. |
| `spi_bus` | integer | Optional | SPI bus number used to connect the gateway peripheral. <br> Options: `0`, `1` |
| `region_code` | string | Optional | Frequency region of your gateway. <br> Options: `US915`, `EU868` <br> Default: `US915` |
| `reset_pin` | integer | **Required** | GPIO pin used for peripheral reset. <br> Not configurable for `sx1302-waveshare-hat`. |
| `power_en_pin` | integer | Optional | GPIO pin used for peripheral power enable. <br> Not configurable for `sx1302-waveshare-hat`. |
| `path` | string | Optional | Serial path that the peripheral is mounted at, if connected through USB. <br> Not configurable for `sx1302-waveshare-hat`. |

The following attributes are available for RAK7391 gateways:

<!-- prettier-ignore -->
| Name | Type | Required? | Description |
| ---- | ---- | --------- | ----------- |
| `board` | string | **Required** | Name of the [board component](/operate/reference/components/board/) that represents the Raspberry Pi Compute Module inside the RAK7391. Used for GPIO pin control. |
| `region_code` | string | Optional | Frequency region of your gateway. <br> Options: `US915`, `EU868` <br> Default: `US915` |
| `pcie1` | object | optional | PCIe configuration for concentrator connected to PCIe slot 1: <br> <ul><li>`spi_bus` (integer) (Optional): SPI bus that the concentrator is connected to, if connected through SPI. </li><li>`serial_path` (string) (Optional): Serial path that the concentrator is mounted at, if connected through USB. </li></ul> |
| `pcie2` | object | Optional | PCIe configuration for concentrator connected to PCIe slot 2: <br> <ul><li>`spi_bus` (integer) (Optional): SPI bus that the concentrator is connected to, if connected through SPI. </li><li>`serial_path` (string) (Optional): Serial path that the concentrator is mounted at, if connected through USB. </li></ul> |

## Add a node

Complete the following steps to configure your node:

{{< tabs >}}
{{% tab name="Builder" %}}

1. Navigate to the **CONFIGURE** tab of your machine's page in the [Viam app](https://app.viam.com).
1. Click the **+** icon next to your machine part in the left-hand menu and select **Component or service**.
1. Select the `sensor` type, then select the `lorawan` model that matches the name of your node.
   If the name of your node does not appear in the list, choose the generic `lorawan:node` option.
1. Click **Add module**, and enter a name for your node.
1. Click **Create** to add the module to your machine.
1. Click **Save** in the top right to apply your changes and load your new module.

{{% /tab %}}
{{% tab name="JSON Configuration" %}}

In the `components` section of your machine configuration, add the following object, depending on your preferred [activation protocol](#activation-protocols):

{{< tabs >}}
{{% tab name="OTAA" %}}

```json
{
  "name": "<your-node-name>",
  "api": "rdk:component:sensor",
  "model": "viam:lorawan:<node-name>",
  "attributes": {
    "join_type": "OTAA",
    "dev_eui": <device-eui>,
    "app_key": <application-key>,
    "gateways": [<gateway-name>]
  }
}
```

{{% /tab %}}
{{% tab name="ABP" %}}

```json
{
  "name": "<your-node-name>",
  "api": "rdk:component:sensor",
  "model": "viam:lorawan:<node-name>",
  "attributes": {
    "join_type": "ABP",
    "dev_addr": <device-address>,
    "app_s_key": <application-session-key>,
    "network_s_key": <network-session-key>,
    "gateways": [<gateway-name>]
  }
}
```

{{% /tab %}}
{{< /tabs >}}

Choose an appropriate node model from the following options:

- `viam:lorawan:dragino-LHT65N`: Dragino LHT65N temperature and humidity sensor.
- `viam:lorawan:dragino-WQSLB`: Dragino WQS-LB water quality sensor
- `viam:lorawan:milesight-ct101`: Milesight CT101 current sensor
- `viam:lorawan:milesight-em310-tilt`: Milesight EM310-TILT sensor
- `viam:lorawan:node`: Any LoRaWAN sensor that is:
  - Class A
  - supports either the `US915` or `EU868` frequency band
  - uses LoRaWAN MAC specification version 1.0.3

Device-specific models for Dragino and Milesight sensors provide default values for `app_key`, `network_s_key`, and `app_s_key`, so you can omit those fields from your configuration.

Configure attributes based on the tables below:

{{% /tab %}}
{{< /tabs >}}

The following attributes are available for nodes:

<!-- prettier-ignore -->
| Name | Type | Required? | Description |
| ---- | ---- | --------- | ----------- |
| `dev_eui` | string | **Required** | The **device EUI (Extended Unique Identifier)**, a unique 64-bit identifier for the LoRaWAN device in hexadecimal format (16 characters). Found on your device or in device packaging. |
| `join_type` | string | Optional | The [activation protocol](#activation-protocols) used to secure this network. <br> Default: "OTAA". <br> Options: "OTAA", "ABP" |
| `app_key` | string | Optional | The 128-bit hexadecimal AES **application key** used for device authentication and session key derivation. Required for OTAA activation protocol. Found in the device datasheet. <br> On `milesight-ct101` and `milesight-em310-tilt`, defaults to `5572404C696E6B4C6F52613230313823`. |
| `dev_addr` | string | Optional | 32-bit hexadecimal **device address** used to identify this device in uplink messages. Required for ABP activation protocol. Found in the device datasheet or in device packaging. |
| `app_s_key` | string | Optional | 128-bit hexadecimal **application session key** used to decrypt uplink messages. Required for ABP activation protocol. Found in the device datasheet or in device packaging. <br> On `milesight-ct101` and `milesight-em310-tilt`, defaults to `5572404C696E6B4C6F52613230313823`. |
| `network_s_key` | string | Optional | 128-bit hexadecimal **network session key** used to decrypt uplink messages. Required for ABP activation protocol. Found in the device datasheet or in device packaging. <br> On `milesight-ct101` and `milesight-em310-tilt`, defaults to `5572404C696E6B4C6F52613230313823`. |
| `gateways` | string[] | **Required** | Name of the [gateway component](#add-a-gateway) in your Viam configuration. |
| `uplink_interval_mins` | decimal | **Required** | Interval between uplink messages sent from the node, in minutes. Found in the device datasheet, but can be modified. Configured by downlink after initial connection. <br> On `milesight-ct101`, defaults to `10`. On `milesight-em310-tilt`, defaults to `1080`. |
| `decoder_path` | string | **Required** | Path to a Javascript **decoder script** used to interpret data transmitted from the node. You can use a local path on your device or an HTTP(S) URL that points to a file on a remote server. If the decoder script provides multiple implementations, uses the Chirpstack version. Not compatible with The Things Network decoders. <br> On supported Milesight and Dragino models, defaults to the latest decoder published by the manufacturer on GitHub. |
| `fport` | string | Optional | 8-bit hexadecimal **frame port** used to send downlinks to the device. Found in the device datasheet. <br> On supported Milesight models, defaults to `"55"` (equivalent to `0x55`). <br> On supported Dragino models, defaults to `"01"` (equivalent to `0x01`). |

{{% alert title="Info" color="info" %}}

Device-specific models, including those for Milesight and Dragino sensors, provide default values for `app_key`, `network_s_key`, `app_s_key`, `fport`, `decoder_path`, and `uplink_interval_mins`.

{{% /alert %}}

### Activation protocols

LoRaWAN networks can use any of the following protocols for communication:

<!-- prettier-ignore -->
| Name | Value | Key | Session Key | Configuration |
| ---- | ----- | --- | ----------- | ------------- |
| Over-The-Air Activation | `OTAA` | Dynamic, generated at join time | Automatically rotated | <ul><li> `dev_eui` </li><li> `app_eui` </li><li> `app_key` </li></ul> |
| Activation By Personalization | `ABP` | Static | Static unless manually rotated | <ul><li> `dev_addr` </li><li> `network_s_key` </li><li> `app_s_key` </li></ul> |

To specify an activation protocol for your network, use the `join_type` field.
Many nodes use the OTAA protocol by default.

### Decoder script

When a LoRaWAN device transmits data, it sends compressed binary payloads to minimize power consumption and airtime.
Decoder scripts convert this binary data into structured, human-readable formats like JSON.

Each manufacturer uses different encoding schemes depending on the data transmitted by a device.
For example:

- A temperature sensor might encode 23.5°C as a hexadecimal value like `0x00EB`
- A GPS tracker might pack latitude and longitude into 8 bytes.

Without a decoder script, your application receives meaningless byte sequences like `0x00EB1337` instead of useful data like `{"temperature": 23.5, "humidity": 42.0 }`.

Device manufacturers typically provide scripts for each device. For examples, see the following GitHub repositories:

- [Milesight](https://github.com/Milesight-IoT/SensorDecoders)
- [Dragino](https://github.com/dragino/dragino-end-node-decoder)

### Frame port

Frame port (`fport`) is an 8-bit field in the LoRaWAN MAC payload structure that defines the data type contained within the frame payload.
Frame ports identify the kind of data passed in an uplink or downlink message so it can be routed to the correct handler, which helps keep LoRaWAN traffic fast, simple, and efficient.

Use the `fport` field of a node configuration to specify the frame port value that the node expects to use for downlink communication.
When you specify an `fport` value for a node, gateways use that value as the frame port for all downlink communication with the node.

## Control nodes directly

You can use [DoCommand](/dev/reference/sdks/docommand/) to configure, control, and calibrate your LoRaWAN nodes. The `lorawan` module supports the following commands:

### Restart node

The following example shows how to restart a node from an SDK:

{{< tabs >}}
{{% tab name="Python" %}}

```python
node = await robot.get_component(Sensor.get_resource_name("<your_node_name>"))

# restart node
await node.do_command({"restart_sensor": {}})
```

{{% /tab %}}
{{% tab name="Flutter" %}}

```dart
final node = Sensor.fromRobot(robot, '<your_node_name>');

# restart node
await node.doCommand({'restart_sensor': {}});
```

{{% /tab %}}

{{% tab name="TypeScript" %}}

```typescript
const node = new SensorClient(client, "<your_node_name>");

# restart node
await node.doCommand({ restart_sensor: {} });
```

{{% /tab %}}
{{< /tabs >}}

### Send a downlink message to a node

The following example shows how to send downlink messages to a node from an SDK:

{{< tabs >}}
{{% tab name="Python" %}}

```python
node = await robot.get_component(Sensor.get_resource_name("<your_node_name>"))

# send downlink message in hexadecimal
await node.do_command({
    "downlink": "48656C6C6F"
})
```

{{% /tab %}}
{{% tab name="Flutter" %}}

```dart
final node = Sensor.fromRobot(robot, '<your_node_name>');

// send downlink message in hexadecimal
await node.doCommand({'send_downlink': '48656C6C6F'});
```

{{% /tab %}}

{{% tab name="TypeScript" %}}

```typescript
const node = new SensorClient(client, "<your_node_name>");

// send downlink message in hexadecimal
await node.doCommand({ send_downlink: "48656C6C6F" });
```

{{% /tab %}}
{{< /tabs >}}

### Configure the transmission interval

The transmission interval controls how often a node communicates with the gateway.
The following example shows how to change the transmission interval of a node from an SDK:

{{< tabs >}}
{{% tab name="Python" %}}

```python
node = await robot.get_component(Sensor.get_resource_name("<your_node_name>"))

# set data transmission interval in seconds
await node.do_command({"set_interval": 300})
```

{{% /tab %}}
{{% tab name="Flutter" %}}

```dart
final node = Sensor.fromRobot(robot, '<your_node_name>');

// set data transmission interval in seconds
await node.doCommand({'set_interval': 300});
```

{{% /tab %}}

{{% tab name="TypeScript" %}}

```typescript
const node = new SensorClient(client, "<your_node_name>");

// set data transmission interval in seconds
await node.doCommand({ set_interval: 300 });
```

{{% /tab %}}
{{< /tabs >}}

### Calibrate the Dragino-WQS-LB water quality sensor

{{% alert title="Info" color="info" %}}

This example only works with the Dragino-WQS-LB sensor.

{{% /alert %}}

The following example shows how to send calibration commands to the Dragino-WQS-LB sensor:

{{< tabs >}}
{{% tab name="Python" %}}

```python
node = await robot.get_component(Sensor.get_resource_name("<your_node_name>"))

# calibrate pH probe
await node.do_command({"calibrate_ph": {}})
# calibrate electrical conductivity probe
await node.do_command({"calibrate_ec": {}})
# calibrate turbidity probe
await node.do_command({"calibrate_t": {}})
# calibrate ORP (Oxidation-Reduction Potential) probe
await node.do_command({"calibrate_orp": {}})
```

{{% /tab %}}
{{% tab name="Flutter" %}}

```dart
final node = Sensor.fromRobot(robot, '<your_node_name>');

// calibrate pH probe
await node.doCommand({'calibrate_ph': {}});
// calibrate electrical conductivity probe
await node.doCommand({'calibrate_ec': {}});
// calibrate turbidity probe
await node.doCommand({'calibrate_t': {}});
// calibrate ORP (Oxidation-Reduction Potential) probe
await node.doCommand({'calibrate_orp': {}});
```

{{% /tab %}}

{{% tab name="TypeScript" %}}

```typescript
const node = new SensorClient(client, "<your_node_name>");

// calibrate pH probe
await node.doCommand({ calibrate_ph: {} });
// calibrate electrical conductivity probe
await node.doCommand({ calibrate_ec: {} });
// calibrate turbidity probe
await node.doCommand({ calibrate_t: {} });
// calibrate ORP (Oxidation-Reduction Potential) probe
await node.doCommand({ calibrate_orp: {} });
```

{{% /tab %}}
{{< /tabs >}}

## View captured data

You can query captured data in the Viam app from the **DATA** page.
To build a dashboard to monitor your captured data using charts and graphs, configure widgets on the **TELEOP** page.

For more information, see [Visualize data](/data-ai/data/visualize/).

## Troubleshooting

### Gateway fails to start

- **Check hardware connections**:

  - If using a HAT, ensure your HAT is properly seated on the SBC's GPIO header.
  - Check that the antenna is securely connected to your gateway.
  - On the Waveshare SX1302 LoRaWAN Gateway HAT, check the status LEDs for activity:
    - **Power LED (red, solid)**: gateway receiving power
    - **TX LED (red, blinking)**: gateway transmitting data
    - **RX LED (red, blinking)**: gateway receiving data

- **Verify pin configuration**:

  - If using a HAT, confirm that `reset_pin` and `power_en_pin` in your gateway configuration match the manufacturer's guidelines for your HAT.
  - Verify that SPI is enabled on your machine.
  - Check that `spi_bus` is configured for the correct SPI bus.

### Sensor fails to join network

- **Wait 10-15 minutes**:
  - Nodes can take up to 10-15 minutes to join the network.
  - If a node doesn't join the network within 30 minutes, try restarting the node.
- **Verify device identifiers**:

  - Check that `dev_eui` in your node configuration matches the value of your device.
  - If you use the OTAA activation protocol, confirm that `app_key` matches the application key defined in the device datasheet.
  - If you use the ABP activation protocol, verify that `app_s_key` and `network_s_key` match the values defined in the device datasheet or device packaging.

- **Check network configuration**:

  - Ensure gateway is running with no error logs.
  - Verify that the `gateway` field of the node contains an array that contains only a string that exactly matches the name of your gateway in your machine configuration (for example, `"gateway": [ "example-gateway" ]`).
  - Verify that your gateway and node frequency regions match.

- **Adjust positioning**:
  - Move node closer to gateway for initial setup.
  - Check for physical obstructions.
